module auto_tester ( // auto-tester module for the 16-bit ALU, contains 23 test cases
    input clk,  // clock
    input rst,  // reset
    
    // 5 bit binary number to represent which specific test case shall be failed (inverting LSB of ALU[15:0] of ALU
    // from b00001 (Test Case #1) to b10111 (Test Case #23)
    input fail_case[5],
    
    input switch[2], // io_dip[2][7] is the toggle to start the auto_tester, io_dip[2][6] is the toggle to reset the auto_tester
    
    output overall[2],// // overall for all test cases, b00 means still testing, b01 means PASS, b10 means FAIL
    
    // 6 case_groups
    // b000001) Addition, b000010) Subtraction, b000100) Comparator, b001000) Boolean, b010000) Shifter, b100000) Multiplier
    output case_group[6], // so that it will be easier to see exactly what kind of test cases/ALU operations are being tested
    
    output case1, // to indicate that the first case of the current case_group is being executed
    output case2, // to indicate that the second case of the current case_group is being executed
    output case3, // to indicate that the third case of the current case_group is being executed
    output case4, // to indicate that the fourth case of the current case_group is being executed
    output case5, // to indicate that the fifth case of the current case_group is being executed
    output case6, // to indicate that the sixth case of the current case_group is being executed
    output case7 // to indicate that the seventh case of the current case_group is being executed
    // need up till case7 because the case_group with the largest number of test cases (case_group b011, Comparator) has 7 test cases
    
    // for example, test case #3 is an addition test case that results in a zero, thus this is under
    // case_group = b001 (1), where case6 = 0, case 
    // another example, test case #9, which is a comparator test case of A = B resulting in true, thus this is under
    // case_group = 0b011 (3), where case3 = 0, case2 = 0, case1 = 1 (0b001 = 1), as this is the first test case
    // under the comparator case_group
) 

{
  fsm feeder(.clk(clk), .rst(rst)) = {START, //starting state
                                      S0, S1, S2, S3, // case_group b001, addition
                                      S4, S5, S6, S7, // case_group 0b010, subtraction
                                      S8, S9, S10, S11, S12, S13, S14, // case_group 0b011, comparator
                                      S15, S16, S17, S18, // case_group 0b100, boolean
                                      S19, S20, S21, // case_group 0b101, shifter
                                      S22, // case_group 0b110, multiplier
                                      PASS, FAIL};
  // a total of 25 states, 23 states to represent each of the 23 test cases, PASS state to represent all 23 test cases passed,
  // FAIL state to represent that at least one of the 23 test cases failed
  
  rom1 inputs; // the ROM that provides the inputs (38 bits, A[15:0] + B[15:0] + ALUFN[5:0], concatenated)
  rom2 answers; // the ROM that provides the expected answers (19 bits, ALU[15:0] + Z + V + N, concatenated)
  alu alu;
  sig a[16], b[16], alufn[6], s[16], z, v, n, alu_actual[16];

  always {
    overall = b00; // initial output overall b00, to show that it is still testing the test cases
    inputs.selector = b00000; // assign somethiing to inputs.selector first
    answers.selector = b00000; // assign something to anwers.selector first
    case_group = b000000; // assign something to case_group first
    case1 = 0; // assign something to case1 first
    case2 = 0; // assign something to case2 first
    case3 = 0; // assign something to case3 first
    case4 = 0; // assign something to case4 first
    case5 = 0; // assign something to case5 first
    case6 = 0; // assign something to case6 first
    case7 = 0; // assign something to case7 first
    alu.alufn = b000000; // assign something to input alufn of alu first
    alu.a = b0000000000000000; // assign something to input a of alu first
    alu.b = b0000000000000000; // assign something to input b of alu first
    
    case (feeder.q){ // checks the current state of the FSM, feeder
      feeder.START: // starting state
        if (switch[1]){ // if io_dip[2][7] is high
          feeder.d = feeder.S0; // commence the auto tester by testing Test Case #0
        }
        
        else {
          feeder.d = feeder.START; // keep waiting for io_dip[2][7] to be high
        }
      
      feeder.S0: // Test Case #1 - Addition (No Overflow)
        inputs.selector = b00000;
        answers.selector = b00000;
        case_group = b000001; // case_group 1, addition
        case1 = 1; // to represent that the 1st test case of the current case_group 1 is being tested
        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b00001){ // if Test Case #1 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S1; // next state is state S1 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
         
      feeder.S1: // Test Case #2 - Addition (Positive Overflow)
        inputs.selector = b00001;
        answers.selector = b00001;
        case_group = b001; // case_group 1, addition
        case1 = 0; // reset case1, so that we know only the 2nd test case is being tested
        case2 = 1; // to represent that the 2nd test case of the current case_group 1 is being tested
        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b00010){ // if Test Case #2 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S2; // next state is state S2 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S2: // Test Case #3 - Addition (Negative Overflow)
        inputs.selector = b00010;
        answers.selector = b00010;
        case_group = b000001; // case_group 1, addition
        case2 = 0; // reset case2, so that we know only the 3rd test case is being tested
        case3 = 1; // to represent that the 3rd test case of the current case_group 1 is being tested
        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b00011){ // if Test Case #3 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S3; // next state is state S3 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S3: // Test Case #4 - Addition (Zero)
        inputs.selector = b00011;
        answers.selector = b00011;
        case_group = b000001; // case_group 1, addition
        case3 = 0; // reset case3, so that we know only the 4th test case is being tested
        case4 = 1; // to represent that the 4th test case of the current case_group 1 is being tested
        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b00100){ // if Test Case #4 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S4; // next state is state S4 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S4: // Test Case #5 - Subtraction (No Overflow)
        inputs.selector = b00100;
        answers.selector = b00100;
        case_group = b000010; // case_group 2, subtraction
        case4 = 0; // reset case4
        case1 = 1; // to represent that the 1st test case of the current case_group 2 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b00101){ // if Test Case #5 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S5; // next state is state S5 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S5: // Test Case #6 - Subtraction (Positive Overflow)
        inputs.selector = b00101;
        answers.selector = b00101;
        case_group = b000010; // case_group 2, subtraction
        case1 = 0; // reset case1
        case2 = 1; // to represent that the 2nd test case of the current case_group 2 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b00110){ // if Test Case #6 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S6; // next state is state S6 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S6: // Test Case #7 - Subtraction (Negative Overflow)
        inputs.selector = b00110;
        answers.selector = b00110;
        case_group = b000010; // case_group 2, subtraction
        case2 = 0; // reset case2
        case3 = 1; // to represent that the 3rd test case of the current case_group 2 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b00111){ // if Test Case #7 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S7; // next state is state S7 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S7: // Test Case #8 - Subtraction (Zero)
        inputs.selector = b00111;
        answers.selector = b00111;
        case_group = b000010; // case_group 2, subtraction
        case3 = 0; // reset case3
        case4 = 1; // to represent that the 4th test case of the current case_group 2 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b01000){ // if Test Case #8 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S8; // next state is state S8 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S8: // Test Case #9 - Comparator (Equal, True)
        inputs.selector = b01000;
        answers.selector = b01000;
        case_group = b000100; // case_group 3, comparator
        case4 = 0; // reset case4
        case1 = 1; // to represent that the 1st test case of the current case_group 3 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b01001){ // if Test Case #9 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S9; // next state is state S9 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S9: // Test Case #10 - Comparator (Equal, False)
        inputs.selector = b01001;
        answers.selector = b01001;
        case_group = b000100; // case_group 3, comparator
        case1 = 0; // reset case1
        case2 = 1; // to represent that the 2nd test case of the current case_group 3 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b01010){ // if Test Case #10 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S10; // next state is state S10 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S10: // Test Case #11 - Comparator (Less Than, True)
        inputs.selector = b01010;
        answers.selector = b01010;
        case_group = b000100; // case_group 3, comparator
        case2 = 0; // reset case2
        case3 = 1; // to represent that the 3rd test case of the current case_group 3 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b01011){ // if Test Case #11 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S11; // next state is state S11 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S11: // Test Case #12 - Comparator (Less Than, False)
        inputs.selector = b01011;
        answers.selector = b01011;
        case_group = b000100; // case_group 3, comparator
        case3 = 0; // reset case3
        case4 = 1; // to represent that the 4th test case of the current case_group 3 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b01100){ // if Test Case #12 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S12; // next state is state S12 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S12: // Test Case #13 - Comparator (Less Than Equals To, True)
        inputs.selector = b01100;
        answers.selector = b01100;
        case_group = b000100; // case_group 3, comparator
        case4 = 0; // reset case4
        case5 = 1; // to represent that the 5th test case of the current case_group 3 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b01101){ // if Test Case #13 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S13; // next state is state S13 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S13: // Test Case #14 - Comparator (Less Than Equals To, True + Equal)
        inputs.selector = b01101;
        answers.selector = b01101;
        case_group = b000100; // case_group 3, comparator
        case5 = 0; // reset case5
        case6 = 1; // to represent that the 6th test case of the current case_group 3 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b01110){ // if Test Case #14 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S14; // next state is state S14 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S14: // Test Case #15 - Comparator (Less Than Equals To, False)
        inputs.selector = b01110;
        answers.selector = b01110;
        case_group = b000100; // case_group 3, comparator
        case6 = 0; // reset case6
        case7 = 1; // to represent that the 7th test case of the current case_group 3 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b01111){ // if Test Case #15 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S15; // next state is state S15 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S15: // Test Case #16 - Boolean (AND)
        inputs.selector = b01111;
        answers.selector = b01111;
        case_group = b001000; // case_group 4, boolean
        case7 = 0; // reset case7
        case1 = 1; // to represent that the 1st test case of the current case_group 4 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b10000){ // if Test Case #16 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S16; // next state is state S16 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S16: // Test Case #17 - Boolean (OR)
        inputs.selector = b10000;
        answers.selector = b10000;
        case_group = b001000; // case_group 4, boolean
        case1 = 0; // reset case1
        case2 = 1; // to represent that the 2nd test case of the current case_group 4 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b10001){ // if Test Case #17 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S17; // next state is state S17 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S17: // Test Case #18 - Boolean (XOR)
        inputs.selector = b10001;
        answers.selector = b10001;
        case_group = b001000; // case_group 4, boolean
        case2 = 0; // reset case2
        case3 = 1; // to represent that the 3rd test case of the current case_group 4 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b10010){ // if Test Case #18 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S18; // next state is state S18 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S18: // Test Case #19 - Boolean (A)
        inputs.selector = b10010;
        answers.selector = b10010;
        case_group = b001000; // case_group 4, boolean
        case3 = 0; // reset case3
        case4 = 1; // to represent that the 4th test case of the current case_group 4 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b10011){ // if Test Case #19 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S19; // next state is state S19 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S19: // Test Case #20 - Shifter (Shift Left)
        inputs.selector = b10011;
        answers.selector = b10011;
        case_group = b010000; // case_group 5, shifter
        case4 = 0; // reset case4
        case1 = 1; // to represent that the 1st test case of the current case_group 5 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b10100){ // if Test Case #20 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S20; // next state is state S20 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S20: // Test Case #21 - Shifter (Shift Right)
        inputs.selector = b10100;
        answers.selector = b10100;
        case_group = b010000; // case_group 5, shifter
        case1 = 0; // reset case1
        case2 = 1; // to represent that the 2nd test case of the current case_group 5 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b10101){ // if Test Case #21 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S21; // next state is state S21 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S21: // Test Case #22 - Shifter (Arithmetic Shift Right)
        inputs.selector = b10101;
        answers.selector = b10101;
        case_group = b010000; // case_group 5, shifter
        case2 = 0; // reset case2
        case3 = 1; // to represent that the 3rd test case of the current case_group 5 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b10110){ // if Test Case #22 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.S22; // next state is state S22 if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.S22: // Test Case #23 - Multiplication
        inputs.selector = b10110;
        answers.selector = b10110;
        case_group = b100000; // case_group 6, multiplication
        case3 = 0; // reset case3
        case1 = 1; // to represent that the 1st test case of the current case_group 6 is being tested

        a = inputs.out[37:22];// A[15:0]
        b = inputs.out[21:6];// B[15:0]
        alufn = inputs.out[5:0];// ALUFN[5:0]
        s = answers.out[18:3]; // ALU[15:0]
        z = answers.out[2]; // Z
        v = answers.out[1]; // V
        n = answers.out[0]; // N
        
        // feeding the inputs into the ALU
        alu.alufn = alufn;
        alu.a = a;
        alu.b = b;
        alu_actual = alu.alu; // assign the alu output of the alu to alu_actual
        
        if (fail_case == b10111){ // if Test Case #23 is chosen to fail
          alu_actual[0] = ~alu_actual[0]; // inverts the LSB of alu_actual
        }
        
        if (alu_actual == s & alu.z == z & alu.v == v & alu.n == n){
          feeder.d = feeder.PASS; // next state is state PASS if correct (i.e. the ALU's output matches the expected answer)
        }
        
        else{
          feeder.d = feeder.FAIL; // next state is state FAIL if wrong (i.e. the ALU's output does not match the expected answer)
        }
        
      feeder.PASS:
        overall = b10;
        
        if (switch[0]){ // if io_dip[2][6] is high, then reset the auto_tester by going back to the START state
          feeder.d = feeder.START; // go back to the START state
        }
        
        else{ // else, keep waiting for the io_dip[2][6] to be high
          feeder.d = feeder.PASS;
        }
        
      feeder.FAIL:
        overall = b01;
        
        if (switch[0]){ // if io_dip[2][6] is high, then reset the auto_tester by going back to the START state
          feeder.d = feeder.START; // go back to the START state
        }
        
        else{ // else, keep waiting for the io_dip[2][6] to be high
          feeder.d = feeder.PASS;
        }
    }
  }
}
